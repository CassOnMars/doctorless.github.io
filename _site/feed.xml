<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-02-11T20:01:50-08:00</updated><id>http://localhost:4000/</id><title type="html">doctorless.sh</title><subtitle>A basic blog for a basic bit-twiddler who can't give more than their two bits.</subtitle><entry><title type="html">Your Company Should Have A Red Team</title><link href="http://localhost:4000/2017-08-11-your-company-should-have-a-red-team" rel="alternate" type="text/html" title="Your Company Should Have A Red Team" /><published>2017-08-11T00:00:00-07:00</published><updated>2017-08-11T00:00:00-07:00</updated><id>http://localhost:4000/your-company-should-have-a-red-team</id><content type="html" xml:base="http://localhost:4000/2017-08-11-your-company-should-have-a-red-team">&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1600/1*uSGYOkkgQ-XVKfdXVOPQjw.png&quot; alt=&quot;red team&quot; title=&quot;red team&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In the parlance of the Intelligence Community (IC), there exists the concept of a “Red Team” — an oppositional yet internal force which has the sole purpose of finding weaknesses, in order to assess risk and improve effectiveness at handling risk. In the corporate world, this term is more narrow, in that it typically applies to a team tasked with finding vulnerabilities, both in the software produced within, and the surrounding infrastructure (physical and digital). If you don’t already have one, you should seriously consider starting one. If it is too much to ask to have resources dedicated to this full time, then it should at least be something that an internal team is performing part time, preferably as a blend of members from different engineering teams. The resource cost of not having one may far outweigh the possible financial, reputational, and legal costs — an ounce of prevention, etc. While I write this article with an aim towards tech companies, this isn’t something to be ignored by non-tech industries; even a theoretical paper-only clinic need worry about social engineering, for example.&lt;/p&gt;

&lt;h2 id=&quot;why-should-i-care&quot;&gt;Why Should I Care?&lt;/h2&gt;

&lt;p&gt;As time marches on, hardware gets cheaper, and the Internet grows more deeply connected. Cyberattacks once considered sophisticated a decade ago are now a normal, automated component of an attacker’s arsenal. Today, fuzz testing serves as the method of choice for many bug bounty hunters. Tomorrow, this will likely be just another step in the automated scanners crawling the web on behalf of criminals in attacker-friendly nations. Having a team internally deploying the same tactics without having to worry about detection¹ gives you a greater peace of mind in ensuring the safety of your business.&lt;/p&gt;

&lt;p&gt;Detection concerns aside, a red team also has an advantage that attackers do not always have. Information about your infrastructure: the network map, the equipment used, logs, and especially the &lt;em&gt;source code and application infrastructure&lt;/em&gt; all make a potential hacker’s job exponentially easier — and your team has it from the start.&lt;/p&gt;

&lt;p&gt;Don’t read into the above as an implicit approval of security through obscurity. There is little benefit to insider knowledge overall, and assumptions of safety guarantees can make teams more prone to making very costly mistakes. This applies in multiple levels. Many large businesses have internal supporting applications, where the assumption of the application remaining internal has lead to &lt;a href=&quot;http://www.zdnet.com/article/anatomy-of-the-target-data-breach-missed-opportunities-and-lessons-learned/&quot;&gt;actual data breaches&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;how-do-i-assemble-a-red-team&quot;&gt;How Do I Assemble A Red Team?&lt;/h2&gt;

&lt;p&gt;If you don’t already have an active security or risk management team that can take on this role, you can certainly source from within. There are many engineers that are naturally curious, however they may feel fear of retribution either from other team members or their superiors if there is not a written policy allowing this. Conversely, you would not want to grant your employees the right to start digging around wherever they’d like. Having a clear call to action for a pentest team to assemble, with some reasonable guidelines on what constitutes acceptable behavior can go a long way.&lt;/p&gt;

&lt;p&gt;The limits to allowable discovery should be reasonably soft, as long as proper disclosure is made to the right individuals who can record the incident and rectify it. In some sense, this policy should resemble the rules surrounding bug bounty programs many businesses offer. For starters:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Define the areas of most interest, ranked in priority. This will likely start at your most popular software, down to the components and equipment (if applicable) your applications rely on.&lt;/li&gt;
  &lt;li&gt;Define what is out of scope. Production servers with customer data would likely fall under this, as would internal information not related to the product your company offers (like HR records, for example).&lt;/li&gt;
  &lt;li&gt;Devise a secure disclosure policy. This can be as simple as walking over to the affected team to let them know and demo a proof of concept, to encrypted reports with a decryption key shared with the affected team. In larger companies, it can be riskier to use ticketing systems with all-employee access, as an unscrupulous employee can walk out the door armed with this information.&lt;/li&gt;
  &lt;li&gt;Optionally, offer rewards based on the severity of the vulnerability.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;There is naturally going to be a lot of variance for your implementation, as every company has their own distinct no-go zones, and sometimes those can even have overlap with their own product if they are &lt;a href=&quot;https://newrepublic.com/article/115349/dogfooding-tech-slang-working-out-glitches&quot;&gt;dogfooding&lt;/a&gt; (and if you can, you should!).&lt;/p&gt;

&lt;p&gt;Unlike WarGames, the only winning move &lt;em&gt;*is*&lt;/em&gt; to play.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;[1] Bear in mind, there are considerations to make if your infrastructure is hosted in third party services; most require disclosure upfront about automated scans and penetration testing, and that you do so at a time scheduled in advance.&lt;/p&gt;</content><author><name></name></author><summary type="html"></summary></entry><entry><title type="html">Building a Rust Phone, Part 1: Picking the Platform</title><link href="http://localhost:4000/2017-01-11-rust-phone-part-1" rel="alternate" type="text/html" title="Building a Rust Phone, Part 1: Picking the Platform" /><published>2017-01-11T00:00:00-08:00</published><updated>2017-01-11T00:00:00-08:00</updated><id>http://localhost:4000/rust-phone-part-1</id><content type="html" xml:base="http://localhost:4000/2017-01-11-rust-phone-part-1">&lt;p&gt;In &lt;a href=&quot;/2017-01-08-rust-phone-part-0&quot;&gt;Part 0&lt;/a&gt;, I cover the justifications behind building a custom cellphone. In short, security cannot be guaranteed in the current offerings. I picked Rust as a language due to it being able to still work well at a low level, but has a more concise (read: fewer bugs) syntax than C and has better memory safety than C and C++. Before I jump into my (mis)adventures in &lt;em&gt;actually writing code&lt;/em&gt;, there’s still one more aspect to consider — the hardware.&lt;/p&gt;

&lt;p&gt;As mentioned in the prior article, I intend to base the phone on the Rust OS project, &lt;a href=&quot;https://www.redox-os.org/&quot;&gt;Redox&lt;/a&gt;. If you’ve already participated in the project, or at least tried running it on your own hardware, you’d know it is still in its early days, and cannot run with full hardware support on much of anything. Knowing this, I’d have to still implement my own drivers for whatever hardware I choose, and potentially have to write my own bootloader, and any additional supporting assembly code if, say, an ARM processor was chosen. There are a lot of development ARM boards out there, most notably the Raspberry Pi. I think it’s great for certain purposes, but it’s computational power leaves something to be desired when compared to higher end phones. I’m not just wanting to build a custom cellphone for hobbyist use — I’m wanting it to be a reasonable replacement for my day-to-day phone — an iPhone 6+.&lt;/p&gt;

&lt;p&gt;As part of the research I conducted in Part 0, I realized very quickly SoC solutions that merge the AP and BP are incredibly dangerous, and are entirely unauditable, and while some phones (like mine) &lt;em&gt;do&lt;/em&gt; physically separate the two components, literally the only guarantee that can be made by manufacturers to the inaccessibility of hardware (either directly or indirectly) to the BP is through &lt;em&gt;code&lt;/em&gt;, which coincidentally, still can’t be fully audited (at best), or is completely unavailable (at worst). This is because, there does not exist a modern cell phone that has a physical (important distinction; code doesn’t count) killswitch to the baseband processor. Worse still, more and more manufacturers are making it impossible to remove (or replace) the battery, and so on top of the inherent danger of the BP (especially in SoC implementations), there’s the additional risk of power potentially being available to the BP and other hardware, even if the phone is “off”.&lt;/p&gt;

&lt;h2 id=&quot;hardware-requirements&quot;&gt;Hardware Requirements&lt;/h2&gt;

&lt;p&gt;So for the hardware, I’ve got five major goals:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Find a way to adequately &lt;em&gt;separate the BP from the rest of the hardware&lt;/em&gt; (preferably with a killswitch).&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;All hardware must be supported with open source drivers&lt;/em&gt; on Linux, so that there exists a reference for implementation on Redox (with a caveat, in that these drivers either must be separate from the Linux codebase with a compatible license for Redox, or I must keep the codebase of the driver implementation separate from Redox to avoid my contributions to Redox being responsible for poisoning the license with GPL’d code (if unfamiliar with the GPL, either look at the &lt;a href=&quot;https://www.gnu.org/licenses/gpl-faq.html&quot;&gt;FAQ&lt;/a&gt; or the &lt;a href=&quot;https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html&quot;&gt;GPL (v2, for Linux)&lt;/a&gt; itself. While some would argue that the vast difference in implementations should warrant no concern for license poisoning, there have been enough court cases over licensing issues explicitly involving the GPL that I would rather keep it separate if any concern &lt;em&gt;could&lt;/em&gt; exist, and wait for someone more qualified (a lawyer specialized in software licenses) to comment.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;I don’t want to slave my life away by making the challenge more difficult.&lt;/em&gt; Since I’m intending on basing the software on Redox, I’d really rather not want to put more effort into simply porting it to a different architecture than what it currently supports.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;The hardware must be competitive for performance with my current phone.&lt;/em&gt; And if I want to do that, I’ve got to match (or beat!) its specs:
 &lt;em&gt;CPU+GPU&lt;/em&gt;: Apple A8 — 1.4GHz Dual Core ARM (ARMv8A instruction compatible, 64KB[data]+64KB[instruction] L1 cache[per core], 1MB L2 cache[shared], and a 4MB L3 cache [SoC-wide]), plus a 4 core PowerVR GX6450 (according to AnandTech)
 &lt;em&gt;RAM&lt;/em&gt;: 1 GB LPDDR3
 &lt;em&gt;Baseband Processor&lt;/em&gt;: Qualcomm MDM9625M (note that while this processor is physically separate from the CPU, it is virtually unable to be guaranteed [by the public] that it cannot obtain access to other hardware components besides the portion of memory it is supposed to)
 &lt;em&gt;WiFi&lt;/em&gt;: 2.4GHz + 5GHz 802.11a/b/g/n/ac
 &lt;em&gt;Bluetooth&lt;/em&gt;: 4.2
 &lt;em&gt;Storage&lt;/em&gt;: 128GB
 &lt;em&gt;USB&lt;/em&gt;: 2.0
 &lt;em&gt;Screen&lt;/em&gt;: 5.5” IPS (1920x1080) Capacitive Touch Screen
 &lt;em&gt;Battery&lt;/em&gt;: 2915 mAh
 &lt;em&gt;Camera&lt;/em&gt;: 8MP back, 1.2MP front&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;The complete device must be reasonably portable as a cellphone.&lt;/em&gt; This is arguably the toughest problem out of the lot. I’m not saying I expect it’s going to be as slim as my current phone. Even lots of hobbyist development boards are excluded by this requirement either due to their shape or power needs. It’s not a replacement if I have to be stuck to an AC plug, carry around a 12 V car battery, or look like this guy:&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1600/1*WPLRx0DVQrBIKC4PxgfWRA.png&quot; alt=&quot;this guy&quot; title=&quot;this guy&quot; /&gt;
I’m a dedicated, paranoid hobbyist, but I still don’t want to be &lt;em&gt;that guy&lt;/em&gt; on the metro.&lt;/p&gt;

&lt;p&gt;I began the search by looking for a BP that was either easily removable (in a non-destructive manner), or could easily have a physical on/off switch put in place. In other words, it wasn’t going to be soldiered onto a board. While some offerings were available with a GPIO connector, I found this odd due to the bandwidth of data transfer over GPIO relative to the speed of LTE. I2C LTE modules exist, but it is far too low level, abstraction-wise, to be safe. The only other kind of bus that had available modules which also had sufficient bandwidth was USB, and as noted in Part 0, there are concerns with DMA attacks with that option. I left out a good deal of explanation behind how DMA attacks work, and how to prevent them in the prior article, because for one, adequately explaining it would be an article or two in of itself, and two, I had hoped that there may be a reasonable alternative to a USB device, but in reality, it seems to very expediently solve my need for a higher-level abstraction with a very obvious killswitch (unplug it). So without writing an article within an article, the TL;DR to preventing DMA attacks from USB on a hardware level is to ensure your processor has a form of IOMMU which supports interrupt remapping (let alone have an IOMMU at all).&lt;/p&gt;

&lt;h2 id=&quot;narrowing-it-down&quot;&gt;Narrowing It Down&lt;/h2&gt;

&lt;p&gt;A number of ARM development boards definitely cropped up, but most of them lacked in processing power to match my current environment, or was intended for other purposes to the point where the formfactor became unreasonable. I was rather excited after finding the MediaTek X20 development board, until digging into the deep, poorly-translated documentation revealed a dormant BP inside the SoC, along with other concerning elements. A similar experience was found with the very limited number of qualifying ARM boards.&lt;/p&gt;

&lt;p&gt;x86? The thought of a strapping a laptop equivalent to my head to answer a call didn’t sound enticing.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/1600/1*rU1G6bJ_JydSZlcEzhpgPQ.png&quot; alt=&quot;me guy&quot; title=&quot;me guy&quot; /&gt;
This is unreasonable.&lt;/p&gt;

&lt;p&gt;I kept searching for options, with some very exotic (read: difficult to support) processors, but kept coming to the same conclusion: x86 isn’t so bad. In fact, there are some small form factors, such as Intel’s NUC. And the Atom is pretty power efficient. But other than platforms that were too limited, like Edison and Galileo, options seemed out of reach — the Compute Card announced at CES isn’t available yet, and the docking station’s internals aren’t public yet, so waiting may not even be worth it. But then I remembered this sleeper car of a device: the Intel Compute Stick!&lt;/p&gt;

&lt;p&gt;Here’s the specs on the lowest-end model of the latest (Q1 2016, sadly, but it is latest) iteration, the STK1AW32SC:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;CPU&lt;/em&gt;: Intel Atom x5-Z8330 Processor — 1.92GHz quad-core, 24KB(data)+32KB(instruction) L1 Cache (per core), 2MB L2 Cache (shared)
&lt;em&gt;GPU&lt;/em&gt;: Intel HD Graphics 400
&lt;em&gt;RAM&lt;/em&gt;: 2GB DDR3L-1600
&lt;em&gt;WiFi&lt;/em&gt;: 2.4GHz + 5GHz 802.11a/b/g/n/ac
&lt;em&gt;Bluetooth&lt;/em&gt;: 4.2
&lt;em&gt;Storage&lt;/em&gt;: onboard 32GB, microSD slot allows up to an additional 128GB
&lt;em&gt;USB&lt;/em&gt;: 1 USB 3.0, 1 USB 2.0
&lt;em&gt;Video Out&lt;/em&gt;: HDMI 1.4b
&lt;em&gt;Power In&lt;/em&gt;: 5V, 3A max current
&lt;em&gt;Price&lt;/em&gt;: $129&lt;/p&gt;

&lt;p&gt;Perfect.&lt;/p&gt;

&lt;h2 id=&quot;finding-what-remains&quot;&gt;Finding What Remains&lt;/h2&gt;

&lt;p&gt;This leaves us with needing to fill in the gaps: a touchscreen, a battery, and either one or two cameras (sticking with one for now), and of course, the baseband processor (plus necessary RF components).&lt;/p&gt;

&lt;p&gt;While the world of touchscreens is somewhat of a mixed bag, many of the screens in cellphones take in some form of MIPI DSI or eDP connector, and even more fortuitous for someone wanting to start a project like this now, Toshiba has brought an HDMI to DSI chip (TC358870XBG) to market. Due to this, there is now a flood of excellent 1080P and 1440P screens in handheld sizes that I can use with this project, ranging from $100–200. At this point, however, I’m nowhere near ready to start implementing input for a digitizer or a camera, so I’ll leave that for a later article.&lt;/p&gt;

&lt;p&gt;As for the battery, there exist many “power banks” on the market which can provide a 5V/3A output, some rated upwards of 30,000 mAh, all within very portable sizes. Again, there is little point in obtaining this yet, as I’m nowhere near ready to start taking this outside. Similarly, many USB BPs exist on the market, some of which have Linux drivers. This too, shall wait for another day.&lt;/p&gt;

&lt;p&gt;Next up is Part 2: Attempting to Boot.&lt;/p&gt;</content><author><name></name></author><summary type="html">In Part 0, I cover the justifications behind building a custom cellphone. In short, security cannot be guaranteed in the current offerings. I picked Rust as a language due to it being able to still work well at a low level, but has a more concise (read: fewer bugs) syntax than C and has better memory safety than C and C++. Before I jump into my (mis)adventures in actually writing code, there’s still one more aspect to consider — the hardware.</summary></entry><entry><title type="html">Building a Rust Phone, Part 0: Justifications</title><link href="http://localhost:4000/2017-01-08-rust-phone-part-0" rel="alternate" type="text/html" title="Building a Rust Phone, Part 0: Justifications" /><published>2017-01-08T00:00:00-08:00</published><updated>2017-01-08T00:00:00-08:00</updated><id>http://localhost:4000/rust-phone-part-0</id><content type="html" xml:base="http://localhost:4000/2017-01-08-rust-phone-part-0">&lt;p&gt;If you were to ask the entirety of people who know me what is one attribute that stands out about myself, they will say that, without a shadow of a doubt, I am the most paranoid person they know — and for good reason. Since I can remember using a computer, I was always figuring out new ways to break things from a security perspective. This tendency never ended, although now I work from a white hat perspective. My philosophy of “if it can be broken, it must” didn’t stop at a digital boundary. Physical security matters just as much to me and the lines have blurred much in the last decade, a great deal in part thanks to our reliance on cellphones. As I will explain below, there is not a single cellphone on the market that can be trusted. And so, I set out to build my own, with a design that makes security the highest priority. For the time being, I plan on using and extending the Rust OS, Redox.&lt;/p&gt;

&lt;h2 id=&quot;if-it-can-be-broken-itmust&quot;&gt;If It Can Be Broken, It Must&lt;/h2&gt;
&lt;p&gt;I’m not going to bore with a CV of prior exploits. In fact, almost all of my security work has been performed through private disclosure to software vendors, or at my place at employment, both of which do not leave much for a public trail. Even so, it’s not news to anyone that the technological infrastructure of our modern world is incredibly fragile, a byproduct of two incredibly mistaken beliefs:&lt;/p&gt;

&lt;p&gt;First, the reliance on open source in that it merely being open means all the eyes that look at it have the best intentions, and of those that do, their intention is to hone in on the potential vulnerabilities that lie within. OpenSSL has in recent history proven this multiple times, enough to induce a major fork — LibreSSL.&lt;/p&gt;

&lt;p&gt;Second, and conversely, that the iron-clad guarantees of commercial support better guarantee the security of enterprise proprietary solutions. This too has had its fair share of recent incidents, such as the Equation Group leak.&lt;/p&gt;

&lt;p&gt;And this only covers the software side. What about hardware? With respect alone to the baseband processor (BP) in every cellphone, &lt;a href=&quot;http://www.osnews.com/story/27416/The_second_operating_system_hiding_in_every_mobile_phone&quot;&gt;there&lt;/a&gt; &lt;a href=&quot;https://boingboing.net/2016/07/20/baseband-vulnerability-could-m.html&quot;&gt;are&lt;/a&gt; &lt;a href=&quot;https://events.ccc.de/congress/2011/Fahrplan/attachments/2022_11-ccc-qcombbdbg.pdf&quot;&gt;innumerable&lt;/a&gt; &lt;a href=&quot;https://www.usenix.org/system/files/conference/woot12/woot12-final24.pdf&quot;&gt;reports&lt;/a&gt; about the concerning state of affairs. To save you a click or two, the problem in BPs boils down to this: the myriad of technologies required to properly handle all the communication standards for cellphones for even a single provider is complex, patent encumbered, and expensive. Every BP provider must have their hardware and software certified by the FCC, which in of itself is prohibitively expensive for any open solution to emerge (at the very least, legally). No manufacturer wants to lose what little edge their incremental developments gain them, so both the software and hardware remains closed, and as sourced above, ripe for the picking of hackers, especially on the state level.&lt;/p&gt;

&lt;p&gt;So here we are, in a situation where every BP is a fragile black box, where only those willing to break the law (or in some cases, are above the law) are the ones able to truly avoid it, or take advantage of it. Worse still, we not only blindly trust these providers, we fully accept that they include these processors in a single chip solution that merges the application processor (AP) with it, with varying degrees of largely unauditable levels of separation. Assuming (which is probably safe, despite my own paranoia saying otherwise) that manufacturers are honest about how they separate BPs from APs in SoC offerings, most of them are using a form of USB which resides inside the chip: HSIC. For simplicity, assume it is the same thing. The problem with USB is that while all versions of USB prior to 3.1 do not support DMA directly, it is entirely possible through faulty design that such a possibility does exist where the USB controller could be hacked, which resides at a level where DMA could be performed, meaning that even with best intentions and industry standard levels of separation, it is entirely possible for the best-engineered SoC AP/BP solutions to allow for BP access to memory not intended to be seen by the BP. That scares me, &lt;em&gt;and it should scare you too&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;With no visibility to the actions or actual communications with a BP from cell networks, and their sheer willingness to connect to whatever will talk to it (else, Stingrays would not be effective), from a security-minded perspective where &lt;em&gt;if it can be broken, it must&lt;/em&gt;, a stark, disturbing reality emerges: no modern cellphone is safe, and you can (and should) assume that any interface, camera, microphone, GPS, storage, memory, etc. can be accessed remotely by the BP without your knowledge at any time.&lt;/p&gt;</content><author><name></name></author><summary type="html">If you were to ask the entirety of people who know me what is one attribute that stands out about myself, they will say that, without a shadow of a doubt, I am the most paranoid person they know — and for good reason. Since I can remember using a computer, I was always figuring out new ways to break things from a security perspective. This tendency never ended, although now I work from a white hat perspective. My philosophy of “if it can be broken, it must” didn’t stop at a digital boundary. Physical security matters just as much to me and the lines have blurred much in the last decade, a great deal in part thanks to our reliance on cellphones. As I will explain below, there is not a single cellphone on the market that can be trusted. And so, I set out to build my own, with a design that makes security the highest priority. For the time being, I plan on using and extending the Rust OS, Redox.</summary></entry></feed>